#![cfg_attr(not(test), no_std)]
#![allow(unexpected_cfgs)]

// Re-exports
pub mod program_error {
    pub use jiminy_program_error::*;
}
use core::mem::{size_of, MaybeUninit};

use program_error::*;

pub trait SysvarId {
    const ID: [u8; 32];
}

// Dev Notes for SimpleSysvar:
//
// We used to enforce `align_of() == 1` and use packed byte array structs
// but the generated bytecode would involve all kinds of crazy inefficient unaligned memory accesses.
// For example, copying a Clock struct would use 8x load-stores
// with differing bytewidths instead of 5x 8-byte load-stores, one for each 8-byte
// field. So we've decided to preserve higher alignments at the cost of more unsafe.
//
// Also, no difference in bytecode was observed between whether the packed byte array
// struct was defined as one big byte array or individual fields of byte arrays.

/// A sysvar that:
/// - is small enough to be read out in whole via the sysvar syscall
///   without exceeding stack size
/// - has the same in-memory representation as its serialized format
///   that is returned by the syscall, at least for the first few bytes
///   before external/suffix padding. This means:
///     - no internal padding between fields
///     - primitive fields must have the same endianness
///       in the serialized format as the solana vm (little-endian).
///
/// # Safety
/// - implementors must make sure the above requirements are met
pub unsafe trait SimpleSysvar: SysvarId + Copy {
    /// Size of the account data of the sysvar.
    ///
    /// This is `size_of::<Self>()` for structs with no external/suffix padding,
    /// but may be shorter for types that do have it.
    const ACCOUNT_LEN: usize = size_of::<Self>();

    #[inline]
    fn get() -> Result<Self, ProgramError> {
        let mut res = MaybeUninit::<Self>::uninit();
        Self::write_to(&mut res)?;
        Ok(unsafe { res.assume_init() })
    }

    /// This is potentially more compute-efficient than [`Self::get`] by explicitly specifying
    /// `dst` as an out-pointer.
    ///
    /// The compiler has proven to be unable to optimize away the move/copy in
    /// `MaybeUninit::assume_init()` in many cases, especially when the returned `Self` is
    /// only dropped at entrypoint exit.
    ///
    /// For example, when calling `set_return_data()` with
    /// `&Clock` after calling `Clock::get()`, the compiler always generates
    /// bytecode that unnecessarily copies the 40 bytes to another location on the stack before calling.
    ///
    /// A memory leak can potentially occur if the initialized value in `dst` is not dropped, but
    /// Self is Copy, so this is ok
    #[inline]
    fn write_to(dst: &mut MaybeUninit<Self>) -> Result<&mut Self, ProgramError> {
        #[cfg(target_os = "solana")]
        {
            let syscall_res = unsafe {
                jiminy_syscall::sol_get_sysvar(
                    Self::ID.as_ptr(),
                    dst.as_mut_ptr().cast(),
                    0,
                    Self::ACCOUNT_LEN as u64,
                )
            };
            match core::num::NonZeroU64::new(syscall_res) {
                None => Ok(unsafe { dst.assume_init_mut() }),
                Some(err) => Err(ProgramError(err)),
            }
        }

        #[cfg(not(target_os = "solana"))]
        {
            core::hint::black_box(dst);
            unreachable!()
        }
    }
}

/// implement [`SimpleSysvar::get()`] as an inherent method
/// so that is is available to call even if the trait is not in scope
#[macro_export]
macro_rules! inherent_simple_sysvar_get {
    () => {
        #[inline]
        pub fn sysvar_get() -> Result<Self, $crate::program_error::ProgramError> {
            <Self as $crate::SimpleSysvar>::get()
        }

        #[inline]
        pub fn sysvar_write_to(
            dst: &mut core::mem::MaybeUninit<Self>,
        ) -> Result<&mut Self, $crate::program_error::ProgramError> {
            <Self as $crate::SimpleSysvar>::write_to(dst)
        }
    };
}

/// Implement pointer casting "serialization"
/// for `SimpleSysvar`s
///
/// # Safety
/// - should only be used for types that impl `SimpleSysvar`
#[macro_export]
macro_rules! impl_cast_to_account_data {
    ($t:ty) => {
        impl $t {
            #[inline]
            pub const fn as_account_data_arr(
                &self,
            ) -> &[u8; <Self as $crate::SimpleSysvar>::ACCOUNT_LEN] {
                // safety: SimpleSysvars means no internal struct padding.
                // Presence of external/suffix padding just means those bytes
                // are not included in the returned array ref.
                unsafe { &*core::ptr::from_ref(self).cast() }
            }
        }
    };
}

/// Implement pointer casting "deserialization"
/// for `SimpleSysvar`s
///
/// # Safety
/// - should only be used for types that impl `SimpleSysvar` and
///   have `size_of::<Self>() == Self::ACCOUNT_LEN`
#[macro_export]
macro_rules! impl_cast_from_account_data {
    ($t:ty) => {
        impl $t {
            /// # Safety
            /// - `account_data` must have the same align as Self
            #[inline]
            pub const unsafe fn of_account_data(
                account_data: &[u8],
            ) -> Result<&Self, ProgramError> {
                match account_data.len() {
                    <Self as $crate::SimpleSysvar>::ACCOUNT_LEN => {
                        Ok(Self::of_account_data_unchecked(account_data))
                    }
                    _ => Err(ProgramError::from_builtin(
                        BuiltInProgramError::InvalidAccountData,
                    )),
                }
            }

            /// # Safety
            /// - `account_data` must be of `size_of::<Self>()`
            /// - `account_data` must have the same align as Self
            #[inline]
            pub const unsafe fn of_account_data_unchecked(account_data: &[u8]) -> &Self {
                Self::of_account_data_arr(&*account_data.as_ptr().cast())
            }

            /// # Safety
            /// - `account_data_arr` must have the same align as Self.
            #[inline]
            pub const unsafe fn of_account_data_arr(
                account_data_arr: &[u8; <Self as $crate::SimpleSysvar>::ACCOUNT_LEN],
            ) -> &Self {
                const {
                    assert!(
                        <Self as $crate::SimpleSysvar>::ACCOUNT_LEN == core::mem::size_of::<Self>()
                    );
                }

                // safety: SimpleSysvar means no internal struct padding,
                // and size equality between byte array and Self is checked at compile-time above
                &*core::ptr::from_ref(account_data_arr).cast()
            }
        }
    };
}
