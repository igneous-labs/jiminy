#![cfg_attr(not(test), no_std)]

//! Errors generated by programs.
//!
//! Considerations:
//!
//! - ProgramError maintains its `NonZeroU64` repr for efficiency; in bpf, returning from a cpi
//!   can simply now just return the r0 register as is for success/error. This comes at the cost of
//!   some debuggability since the errors are limited to their numeric codes. Pair this type with
//!   something else if you need that debuggability.

use core::num::NonZeroU64;

/// pub field: Any non-zero u64 is a valid ProgramError
/// put into r0 on bpf program exit
///
/// Builtin return values occupy the upper 32 bits,
/// while custom errors occupy the lower 32 bits,
/// except for custom error code 0, which is 1 << 32
#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
#[repr(transparent)]
pub struct ProgramError(pub NonZeroU64);

impl ProgramError {
    #[inline]
    pub const fn custom(errcode: u32) -> Self {
        // safety: 0 special-case handled with nonzero value
        Self(unsafe {
            NonZeroU64::new_unchecked(match errcode {
                0 => CUSTOM_ZERO,
                code => code as u64,
            })
        })
    }

    #[inline]
    pub const fn from_builtin(err: BuiltInProgramError) -> Self {
        Self(err.into_nonzero_u64())
    }
}

impl From<NonZeroU64> for ProgramError {
    #[inline]
    fn from(value: NonZeroU64) -> Self {
        Self(value)
    }
}

impl From<BuiltInProgramError> for ProgramError {
    #[inline]
    fn from(value: BuiltInProgramError) -> Self {
        Self::from_builtin(value)
    }
}

impl From<ProgramError> for NonZeroU64 {
    #[inline]
    fn from(ProgramError(v): ProgramError) -> Self {
        v
    }
}

impl From<ProgramError> for u64 {
    #[inline]
    fn from(ProgramError(v): ProgramError) -> Self {
        v.get()
    }
}

const fn to_builtin(err: u64) -> u64 {
    const BUILTIN_BIT_SHIFT: usize = 32;
    err << BUILTIN_BIT_SHIFT
}

pub const CUSTOM_ZERO: u64 = to_builtin(1);
pub const INVALID_ARGUMENT: u64 = to_builtin(2);
pub const INVALID_INSTRUCTION_DATA: u64 = to_builtin(3);
pub const INVALID_ACCOUNT_DATA: u64 = to_builtin(4);
pub const ACCOUNT_DATA_TOO_SMALL: u64 = to_builtin(5);
pub const INSUFFICIENT_FUNDS: u64 = to_builtin(6);
pub const INCORRECT_PROGRAM_ID: u64 = to_builtin(7);
pub const MISSING_REQUIRED_SIGNATURES: u64 = to_builtin(8);
pub const ACCOUNT_ALREADY_INITIALIZED: u64 = to_builtin(9);
pub const UNINITIALIZED_ACCOUNT: u64 = to_builtin(10);
pub const NOT_ENOUGH_ACCOUNT_KEYS: u64 = to_builtin(11);
pub const ACCOUNT_BORROW_FAILED: u64 = to_builtin(12);
pub const MAX_SEED_LENGTH_EXCEEDED: u64 = to_builtin(13);
pub const INVALID_SEEDS: u64 = to_builtin(14);
pub const BORSH_IO_ERROR: u64 = to_builtin(15);
pub const ACCOUNT_NOT_RENT_EXEMPT: u64 = to_builtin(16);
pub const UNSUPPORTED_SYSVAR: u64 = to_builtin(17);
pub const ILLEGAL_OWNER: u64 = to_builtin(18);
pub const MAX_ACCOUNTS_DATA_ALLOCATIONS_EXCEEDED: u64 = to_builtin(19);
pub const INVALID_ACCOUNT_DATA_REALLOC: u64 = to_builtin(20);
pub const MAX_INSTRUCTION_TRACE_LENGTH_EXCEEDED: u64 = to_builtin(21);
pub const BUILTIN_PROGRAMS_MUST_CONSUME_COMPUTE_UNITS: u64 = to_builtin(22);
pub const INVALID_ACCOUNT_OWNER: u64 = to_builtin(23);
pub const ARITHMETIC_OVERFLOW: u64 = to_builtin(24);
pub const IMMUTABLE: u64 = to_builtin(25);
pub const INCORRECT_AUTHORITY: u64 = to_builtin(26);

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum BuiltInProgramError {
    /// The arguments provided to a program instruction were invalid
    InvalidArgument,

    /// An instruction's data contents was invalid
    InvalidInstructionData,

    /// An account's data contents was invalid
    InvalidAccountData,

    /// An account's data was too small
    AccountDataTooSmall,

    /// An account's balance was too small to complete the instruction
    InsufficientFunds,

    /// The account did not have the expected program id
    IncorrectProgramId,

    /// A signature was required but not found
    MissingRequiredSignature,

    /// An initialize instruction was sent to an account that has already been initialized
    AccountAlreadyInitialized,

    /// An attempt to operate on an account that hasn't been initialized
    UninitializedAccount,

    /// The instruction expected additional account keys
    NotEnoughAccountKeys,

    /// Failed to borrow a reference to account data, already borrowed
    AccountBorrowFailed,

    /// Length of the seed is too long for address generation
    MaxSeedLengthExceeded,

    /// Provided seeds do not result in a valid address
    InvalidSeeds,

    /// borsh
    BorshIoError,

    /// An account does not have enough lamports to be rent-exempt
    AccountNotRentExempt,

    /// Unsupported sysvar
    UnsupportedSysvar,

    /// Provided owner is not allowed
    IllegalOwner,

    /// Accounts data allocations exceeded the maximum allowed per transaction
    MaxAccountsDataAllocationsExceeded,

    /// Account data reallocation was invalid
    InvalidRealloc,

    /// Instruction trace length exceeded the maximum allowed per transaction
    MaxInstructionTraceLengthExceeded,

    /// Builtin programs must consume compute units
    BuiltinProgramsMustConsumeComputeUnits,

    /// Invalid account owner
    InvalidAccountOwner,

    /// Program arithmetic overflowed
    ArithmeticOverflow,

    /// Account is immutable
    Immutable,

    /// Incorrect authority provided
    IncorrectAuthority,
}

impl BuiltInProgramError {
    #[inline]
    pub const fn into_u64(self) -> u64 {
        match self {
            Self::InvalidArgument => INVALID_ARGUMENT,
            Self::InvalidInstructionData => INVALID_INSTRUCTION_DATA,
            Self::InvalidAccountData => INVALID_ACCOUNT_DATA,
            Self::AccountDataTooSmall => ACCOUNT_DATA_TOO_SMALL,
            Self::InsufficientFunds => INSUFFICIENT_FUNDS,
            Self::IncorrectProgramId => INCORRECT_PROGRAM_ID,
            Self::MissingRequiredSignature => MISSING_REQUIRED_SIGNATURES,
            Self::AccountAlreadyInitialized => ACCOUNT_ALREADY_INITIALIZED,
            Self::UninitializedAccount => UNINITIALIZED_ACCOUNT,
            Self::NotEnoughAccountKeys => NOT_ENOUGH_ACCOUNT_KEYS,
            Self::AccountBorrowFailed => ACCOUNT_BORROW_FAILED,
            Self::MaxSeedLengthExceeded => MAX_SEED_LENGTH_EXCEEDED,
            Self::InvalidSeeds => INVALID_SEEDS,
            Self::AccountNotRentExempt => ACCOUNT_NOT_RENT_EXEMPT,
            Self::BorshIoError => BORSH_IO_ERROR,
            Self::UnsupportedSysvar => UNSUPPORTED_SYSVAR,
            Self::IllegalOwner => ILLEGAL_OWNER,
            Self::MaxAccountsDataAllocationsExceeded => MAX_ACCOUNTS_DATA_ALLOCATIONS_EXCEEDED,
            Self::InvalidRealloc => INVALID_ACCOUNT_DATA_REALLOC,
            Self::MaxInstructionTraceLengthExceeded => MAX_INSTRUCTION_TRACE_LENGTH_EXCEEDED,
            Self::BuiltinProgramsMustConsumeComputeUnits => {
                BUILTIN_PROGRAMS_MUST_CONSUME_COMPUTE_UNITS
            }
            Self::InvalidAccountOwner => INVALID_ACCOUNT_OWNER,
            Self::ArithmeticOverflow => ARITHMETIC_OVERFLOW,
            Self::Immutable => IMMUTABLE,
            Self::IncorrectAuthority => INCORRECT_AUTHORITY,
        }
    }

    #[inline]
    pub const fn into_nonzero_u64(self) -> NonZeroU64 {
        // safety: none of the consts are 0
        unsafe { NonZeroU64::new_unchecked(self.into_u64()) }
    }
}

impl From<BuiltInProgramError> for NonZeroU64 {
    #[inline]
    fn from(value: BuiltInProgramError) -> Self {
        value.into_nonzero_u64()
    }
}

impl From<BuiltInProgramError> for u64 {
    #[inline]
    fn from(value: BuiltInProgramError) -> Self {
        value.into_u64()
    }
}
