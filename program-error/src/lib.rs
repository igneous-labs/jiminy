#![cfg_attr(not(test), no_std)]

//! Errors generated by programs.
//!
//! Considerations:
//!
//! - ProgramError maintains its `NonZeroU64` repr for efficiency; in bpf, returning from a cpi
//!   can simply now just return the r0 register as is for success/error. This comes at the cost of
//!   some debuggability since the errors are limited to their numeric codes. Pair this type with
//!   something else if you need that debuggability.

use core::{fmt::Display, num::NonZeroU64};

/// pub field: Any non-zero u64 is a valid ProgramError
/// put into r0 on bpf program exit
///
/// Builtin return values occupy the upper 32 bits,
/// while custom errors occupy the lower 32 bits,
/// except for custom error code 0, which is 1 << 32
#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
#[repr(transparent)]
pub struct ProgramError(pub NonZeroU64);

impl ProgramError {
    #[inline(always)]
    pub const fn custom(errcode: u32) -> Self {
        Self(match NonZeroU64::new(errcode as u64) {
            None => CUSTOM_ZERO,
            Some(code) => code,
        })
    }

    #[inline(always)]
    pub const fn from_builtin(err: BuiltInProgramError) -> Self {
        Self(err.into_nonzero_u64())
    }

    /// Returns `Ok(BuiltInProgramError)` if code matched a builtin error,
    /// else `Err(u32 custom user error code)`
    #[inline(always)]
    pub const fn try_into_builtin(self) -> Result<BuiltInProgramError, u32> {
        match BuiltInProgramError::try_from_nonzero_u64(self.0) {
            Some(a) => Ok(a),
            None => Err(match self.0 {
                CUSTOM_ZERO => 0,
                // truncating cast: just take lower 32 bits
                other => other.get() as u32,
            }),
        }
    }

    /// Opposite of [`Self::try_into_builtin`]
    #[inline(always)]
    pub const fn try_into_custom(self) -> Result<u32, BuiltInProgramError> {
        match self.try_into_builtin() {
            Ok(builtin) => Err(builtin),
            Err(custom) => Ok(custom),
        }
    }
}

impl Display for ProgramError {
    #[inline(always)]
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self.try_into_builtin() {
            Ok(builtin) => builtin.fmt(f),
            Err(custom) => f.write_fmt(format_args!("Custom({custom})")),
        }
    }
}

// TODO: reenable when cargo-build-sbf is upgraded
// impl core::error::Error for ProgramError {}

impl From<NonZeroU64> for ProgramError {
    #[inline(always)]
    fn from(value: NonZeroU64) -> Self {
        Self(value)
    }
}

impl From<BuiltInProgramError> for ProgramError {
    #[inline(always)]
    fn from(value: BuiltInProgramError) -> Self {
        Self::from_builtin(value)
    }
}

impl From<ProgramError> for NonZeroU64 {
    #[inline(always)]
    fn from(ProgramError(v): ProgramError) -> Self {
        v
    }
}

impl From<ProgramError> for u64 {
    #[inline(always)]
    fn from(ProgramError(v): ProgramError) -> Self {
        v.get()
    }
}

impl TryFrom<ProgramError> for BuiltInProgramError {
    type Error = u32;

    #[inline(always)]
    fn try_from(value: ProgramError) -> Result<Self, Self::Error> {
        value.try_into_builtin()
    }
}

const fn to_builtin(err: u64) -> NonZeroU64 {
    const BUILTIN_BIT_SHIFT: usize = 32;
    match NonZeroU64::new(err << BUILTIN_BIT_SHIFT) {
        Some(res) => res,
        None => panic!("err = 0"),
    }
}

/// Example-usage:
///
/// ```ignore
/// seqerr!(
///     (CUSTOM_ZERO,),
///     (INVALID_ARGUMENT, InvalidArgument),
/// );
/// ```
///
/// generates:
///
/// ```
/// pub const CUSTOM_ZERO: NonZeroU64 = to_builtin(1);
/// pub const INVALID_ARGUMENT: NonZeroU64 = to_builtin(2);
///
/// impl BuiltInProgramError {
///     #[inline(always)]
///     pub const fn into_nonzero_u64(self) -> NonZeroU64 {
///         match self {
///             Self::InvalidArgument => INVALID_ARGUMENT,
///         }
///     }
///
///     #[inline(always)]
///     pub const fn try_from_nonzero_u64(val: NonZeroU64) -> Option<Self> {
///         Some(match val {
///             INVALID_ARGUMENT => Self::InvalidArgument,
///             _ => return None,
///         })
///     }
/// }
/// ```
macro_rules! seqerr {
    // recursive-case 1: no matching enum variant
    (
        @ctr $ctr:expr;
        @into { $($into:tt)* };
        @try_from { $($try_from:tt)* };

        ($name:ident,)

        $(, $($tail:tt)*)?
    ) => {
        pub const $name: NonZeroU64 = to_builtin($ctr);

        seqerr!(
            @ctr ($ctr + 1);
            @into {$($into)*};
            @try_from {$($try_from)*};
            $($($tail)*)?
        );
    };

    // recursive-case 2: matching enum variant
    (
        @ctr $ctr:expr;
        @into { $($into:tt)* };
        @try_from { $($try_from:tt)* };

        ($name:ident, $var:ident)

        $(, $($tail:tt)*)?
    ) => {
        pub const $name: NonZeroU64 = to_builtin($ctr);

        seqerr!(
            @ctr ($ctr + 1);
            @into {Self::$var => $name, $($into)*};
            @try_from {$name => Self::$var, $($try_from)*};

            $($($tail)*)?
        );
    };

    // base-cases
    (
        @ctr $ctr:expr;
        @into { $($into:tt)* };
        @try_from { $($try_from:tt)* };
    ) => {
        impl BuiltInProgramError {
            #[inline(always)]
            pub const fn into_nonzero_u64(self) -> NonZeroU64 {
                match self {
                    $($into)*
                }
            }

            #[inline(always)]
            pub const fn try_from_nonzero_u64(val: NonZeroU64) -> Option<Self> {
                Some(match val {
                    $($try_from)*
                    _ => return None,
                })
            }
        }
    };
    () => {};

    // start
    ($($tail:tt)*) => {
        seqerr!(
            @ctr 1;
            @into {};
            @try_from {};
            $($tail)*
        );
    };
}

seqerr!(
    (CUSTOM_ZERO,),
    (INVALID_ARGUMENT, InvalidArgument),
    (INVALID_INSTRUCTION_DATA, InvalidInstructionData),
    (INVALID_ACCOUNT_DATA, InvalidAccountData),
    (ACCOUNT_DATA_TOO_SMALL, AccountDataTooSmall),
    (INSUFFICIENT_FUNDS, InsufficientFunds),
    (INCORRECT_PROGRAM_ID, IncorrectProgramId),
    (MISSING_REQUIRED_SIGNATURES, MissingRequiredSignature),
    (ACCOUNT_ALREADY_INITIALIZED, AccountAlreadyInitialized),
    (UNINITIALIZED_ACCOUNT, UninitializedAccount),
    (NOT_ENOUGH_ACCOUNT_KEYS, NotEnoughAccountKeys),
    (ACCOUNT_BORROW_FAILED, AccountBorrowFailed),
    (MAX_SEED_LENGTH_EXCEEDED, MaxSeedLengthExceeded),
    (INVALID_SEEDS, InvalidSeeds),
    (BORSH_IO_ERROR, BorshIoError),
    (ACCOUNT_NOT_RENT_EXEMPT, AccountNotRentExempt),
    (UNSUPPORTED_SYSVAR, UnsupportedSysvar),
    (ILLEGAL_OWNER, IllegalOwner),
    (
        MAX_ACCOUNTS_DATA_ALLOCATIONS_EXCEEDED,
        MaxAccountsDataAllocationsExceeded
    ),
    (INVALID_ACCOUNT_DATA_REALLOC, InvalidRealloc),
    (
        MAX_INSTRUCTION_TRACE_LENGTH_EXCEEDED,
        MaxInstructionTraceLengthExceeded
    ),
    (
        BUILTIN_PROGRAMS_MUST_CONSUME_COMPUTE_UNITS,
        BuiltinProgramsMustConsumeComputeUnits
    ),
    (INVALID_ACCOUNT_OWNER, InvalidAccountOwner),
    (ARITHMETIC_OVERFLOW, ArithmeticOverflow),
    (IMMUTABLE, Immutable),
    (INCORRECT_AUTHORITY, IncorrectAuthority),
);

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum BuiltInProgramError {
    /// The arguments provided to a program instruction were invalid
    InvalidArgument,

    /// An instruction's data contents was invalid
    InvalidInstructionData,

    /// An account's data contents was invalid
    InvalidAccountData,

    /// An account's data was too small
    AccountDataTooSmall,

    /// An account's balance was too small to complete the instruction
    InsufficientFunds,

    /// The account did not have the expected program id
    IncorrectProgramId,

    /// A signature was required but not found
    MissingRequiredSignature,

    /// An initialize instruction was sent to an account that has already been initialized
    AccountAlreadyInitialized,

    /// An attempt to operate on an account that hasn't been initialized
    UninitializedAccount,

    /// The instruction expected additional account keys
    NotEnoughAccountKeys,

    /// Failed to borrow a reference to account data, already borrowed
    AccountBorrowFailed,

    /// Length of the seed is too long for address generation
    MaxSeedLengthExceeded,

    /// Provided seeds do not result in a valid address
    InvalidSeeds,

    /// borsh
    BorshIoError,

    /// An account does not have enough lamports to be rent-exempt
    AccountNotRentExempt,

    /// Unsupported sysvar
    UnsupportedSysvar,

    /// Provided owner is not allowed
    IllegalOwner,

    /// Accounts data allocations exceeded the maximum allowed per transaction
    MaxAccountsDataAllocationsExceeded,

    /// Account data reallocation was invalid
    InvalidRealloc,

    /// Instruction trace length exceeded the maximum allowed per transaction
    MaxInstructionTraceLengthExceeded,

    /// Builtin programs must consume compute units
    BuiltinProgramsMustConsumeComputeUnits,

    /// Invalid account owner
    InvalidAccountOwner,

    /// Program arithmetic overflowed
    ArithmeticOverflow,

    /// Account is immutable
    Immutable,

    /// Incorrect authority provided
    IncorrectAuthority,
}

impl BuiltInProgramError {
    #[inline(always)]
    pub const fn into_u64(self) -> u64 {
        self.into_nonzero_u64().get()
    }

    #[inline(always)]
    pub const fn try_from_u64(val: u64) -> Option<Self> {
        match NonZeroU64::new(val) {
            Some(n) => Self::try_from_nonzero_u64(n),
            None => None,
        }
    }
}

impl Display for BuiltInProgramError {
    #[inline]
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        f.write_fmt(format_args!("{self:#?}"))
    }
}

// TODO: reenable when cargo-build-sbf is upgraded
// impl core::error::Error for BuiltInProgramError {}

impl From<BuiltInProgramError> for NonZeroU64 {
    #[inline(always)]
    fn from(value: BuiltInProgramError) -> Self {
        value.into_nonzero_u64()
    }
}

impl From<BuiltInProgramError> for u64 {
    #[inline(always)]
    fn from(value: BuiltInProgramError) -> Self {
        value.into_u64()
    }
}
